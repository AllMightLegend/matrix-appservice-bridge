<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: components/state-lookup.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: components/state-lookup.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>"use strict";
var __importDefault = (this &amp;&amp; this.__importDefault) || function (mod) {
    return (mod &amp;&amp; mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
/*
Copyright 2020 The Matrix.org Foundation C.I.C.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
const bluebird_1 = __importDefault(require("bluebird"));
const p_queue_1 = __importDefault(require("p-queue"));
const RETRY_STATE_IN_MS = 300;
const DEFAULT_STATE_CONCURRENCY = 4;
class StateLookup {
    /**
     * Construct a new state lookup entity.
     *
     * This component stores state events for specific event types which can be
     * queried at a later date. This component will perform network requests to
     * fetch the current state for a given room ID. It relies on
     * {@link StateLookup#onEvent} being called with later events in order to
     * stay up-to-date. This should be connected to the &lt;code>onEvent&lt;/code>
     * handler on the {@link Bridge}.
     * @constructor
     * @param {Object} opts Options for this constructor
     * @param {MatrixClient} opts.client Required. The client which will perform
     * /state requests.
     * @param {string[]} opts.eventTypes The state event types to track.
     * @throws if there is no client.
     */
    constructor(opts) {
        this.eventTypes = {};
        this.dict = {};
        if (!opts.client) {
            throw new Error("client property must be supplied");
        }
        this.lookupQueue = new p_queue_1.default({
            concurrency: opts.stateLookupConcurrency || DEFAULT_STATE_CONCURRENCY,
        });
        this.retryStateIn = opts.retryStateInMs || RETRY_STATE_IN_MS;
        this._client = opts.client;
        (opts.eventTypes || []).forEach((t) => {
            this.eventTypes[t] = true;
        });
    }
    /**
     * Get a stored state event.
     * @param {string} roomId
     * @param {string} eventType
     * @param {string=} stateKey If specified, this function will return either
     * the event or null. If not specified, this function will always return an
     * array of events, which may be empty.
     * @return {?Object|Object[]}
     */
    getState(roomId, eventType, stateKey) {
        const r = this.dict[roomId];
        if (!r) {
            return stateKey === undefined ? [] : null;
        }
        const es = r.events;
        if (!es[eventType]) {
            return stateKey === undefined ? [] : null;
        }
        if (stateKey !== undefined) {
            return es[eventType][stateKey] || null;
        }
        return Object.keys(es[eventType]).map(function (skey) {
            return es[eventType][skey];
        });
    }
    async getInitialState(roomId) {
        const r = this.dict[roomId];
        try {
            const events = await this.lookupQueue.add(() => this._client.roomState(roomId));
            events.forEach((ev) => {
                if (this.eventTypes[ev.type]) {
                    if (!r.events[ev.type]) {
                        r.events[ev.type] = {};
                    }
                    r.events[ev.type][ev.state_key] = ev;
                }
            });
            return r;
        }
        catch (err) {
            if (err.httpStatus >= 400 &amp;&amp; err.httpStatus &lt; 600) { // 4xx, 5xx
                throw err; // don't have permission, don't retry.
            }
            // wait a bit then try again
            await new Promise((resolve) => setTimeout(resolve, this.retryStateIn));
        }
        return this.getInitialState(roomId);
    }
    /**
     * Track a given room. The client must have access to this room.
     *
     * This will perform a room state query initially. Subsequent calls will do
     * nothing, as it will rely on events being pushed to it via {@link StateLookup#onEvent}.
     *
     * @param {string} roomId The room ID to start tracking. You can track multiple
     * rooms by calling this function multiple times with different room IDs.
     * @return {Promise} Resolves when the room is being tracked. Rejects if the room
     * cannot be tracked.
     */
    trackRoom(roomId) {
        const r = this.dict[roomId] = this.dict[roomId] || {};
        if (r.syncPromise) {
            return r.syncPromise;
        }
        r.events = {};
        // For backwards compat, we use Bluebird
        r.syncPromise = bluebird_1.default.resolve(this.getInitialState(roomId));
        return r.syncPromise;
    }
    /**
     * Stop tracking a given room.
     *
     * This will stop further tracking of state events in the given room and delete
     * existing stored state for it.
     *
     * @param {string} roomId The room ID to stop tracking.
     */
    untrackRoom(roomId) {
        delete this.dict[roomId];
    }
    /**
     * Update any state dictionaries with this event. If there is nothing tracking
     * this room, nothing is stored.
     * @param {Object} event Raw matrix event
     */
    async onEvent(event) {
        if (!this.dict[event.room_id]) {
            return;
        }
        let r = this.dict[event.room_id];
        // Ensure /sync has completed before trying to update.
        if (r.syncPromise.isPending()) {
            r = await r.syncPromise;
        }
        // blunt update
        if (!r.events[event.type]) {
            r.events[event.type] = {};
        }
        r.events[event.type][event.state_key] = event;
    }
}
exports.StateLookup = StateLookup;
//# sourceMappingURL=state-lookup.js.map</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="AgeCounters.html">AgeCounters</a></li><li><a href="AppServiceBot.html">AppServiceBot</a></li><li><a href="Bridge.html">Bridge</a></li><li><a href="BridgeContext.html">BridgeContext</a></li><li><a href="BridgeInternalError.html">BridgeInternalError</a></li><li><a href="global.html#BridgeStore">BridgeStore</a></li><li><a href="Cli.html">Cli</a></li><li><a href="ClientFactory.html">ClientFactory</a></li><li><a href="ClientRequestCache.html">ClientRequestCache</a></li><li><a href="global.html#ConfigValidator">ConfigValidator</a></li><li><a href="EventBridgeStore.html">EventBridgeStore</a></li><li><a href="EventNotHandledError.html">EventNotHandledError</a></li><li><a href="EventQueue.html">EventQueue</a></li><li><a href="EventQueueNone.html">EventQueueNone</a></li><li><a href="EventQueuePerRoom.html">EventQueuePerRoom</a></li><li><a href="EventQueueSingle.html">EventQueueSingle</a></li><li><a href="EventTooOldError.html">EventTooOldError</a></li><li><a href="EventUnknownError.html">EventUnknownError</a></li><li><a href="ForeignNetworkError.html">ForeignNetworkError</a></li><li><a href="Intent.html">Intent</a></li><li><a href="MatrixRoom.html">MatrixRoom</a></li><li><a href="MatrixUser.html">MatrixUser</a></li><li><a href="MembershipCache.html">MembershipCache</a></li><li><a href="PrometheusMetrics.html">PrometheusMetrics</a></li><li><a href="RemoteRoom.html">RemoteRoom</a></li><li><a href="RemoteUser.html">RemoteUser</a></li><li><a href="Request.html">Request</a></li><li><a href="RequestFactory.html">RequestFactory</a></li><li><a href="RoomBridgeStore.html">RoomBridgeStore</a></li><li><a href="RoomLinkValidator.html">RoomLinkValidator</a></li><li><a href="RoomUpgradeHandler.html">RoomUpgradeHandler</a></li><li><a href="StateLookup.html">StateLookup</a></li><li><a href="StoredEvent.html">StoredEvent</a></li><li><a href="UserBridgeStore.html">UserBridgeStore</a></li></ul><h3>Global</h3><ul><li><a href="global.html#defaultMessage">defaultMessage</a></li><li><a href="global.html#wrap">wrap</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.3</a> on Fri Jun 26 2020 10:17:26 GMT+0100 (British Summer Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
